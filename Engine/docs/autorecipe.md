# Autonomous Recipe Authoring for RecipeKit
(using agent-browser + Copilot SDK + Copilot CLI)

## Objective

Build a fully autonomous system that, given a single URL, can:

1. Infer the main semantic topic of a website.
2. Decide where to store the recipe (folder + filename).
3. Automatically generate a valid RecipeKit recipe:
   - First `autocomplete_steps`
   - Then `url_steps` (detail)
4. Validate correctness by generating tests and running the RecipeKit engine.
5. Iteratively repair the recipe using:
   - More web probing via agent-browser
   - Copilot acting as author and fixer
6. Stop only when tests pass or a hard failure condition is reached.

Entrypoint:

bun Engine/scripts/autoRecipe.js --url=https://some-website.com

No list type flags. No manual hints. Autonomy means autonomy.

Dependencies are already installed (including `Engine/node_modules`), so the orchestrator can run the engine and `bun test` immediately during execution.

---

## System roles (non-negotiable)

### agent-browser
The ground truth probe.
It navigates the website, reaches the correct UI state, and extracts minimal, structured evidence.

### Copilot (via Copilot SDK + Copilot CLI)
The reasoning agent.
It:
- infers topic
- proposes folder
- writes RecipeKit steps
- fixes broken recipes based on test failures and new evidence

### autoRecipe.js
The judge and orchestrator.
It:
- validates Copilot output
- enforces naming and schema rules
- writes files
- generates tests
- runs the RecipeKit engine
- controls the repair loop

Copilot proposes.
The script disposes.

---

## Phase 0: Repository structure (match this repo)

Recipes live at repo root, grouped by `list_type` (folder name):

<repo root>/
  <list_type>/
    <domain>.json
    <domain>.autorecipe.test.js        # generated by autoRecipe.js (preferred)
    <list_type>.test.js                # existing, hand-maintained tests
  Engine/
    scripts/
      autoRecipe.js
      prompts/
        classify.md
        author-autocomplete.md
        author-url.md
        fixer.md

Entrypoint:

bun Engine/scripts/autoRecipe.js --url=https://some-website.com

No list-type flags. No manual hints.

---

## Phase 1: Initial web probing and list_type inference

### Step 1.1 – Probe the website (agent-browser)

Goal: capture *just enough* stable evidence for (a) classification and (b) writing selectors.

Collect a single JSON blob (the “evidence packet”) like:

```json
{
  "input_url": "https://example.com/...",
  "final_url": "https://example.com/...",
  "hostname": "example.com",
  "title": "...",
  "meta_description": "...",
  "h1": "...",
  "jsonld_types": ["Product", "Recipe", "WebSite"],
  "links_sample": [
    {"text": "...", "href": "..."}
  ],
  "search": {
    "has_search": true,
    "search_url_template": "https://example.com/search?q=$INPUT",
    "search_box_locator": "input[name=q]",
    "results_container_locator": ".results",
    "result_item_locator": ".result",
    "result_title_locator": ".result .title",
    "result_subtitle_locator": ".result .subtitle",
    "result_url_locator": ".result a",
    "result_cover_locator": "img"
  }
}
```

Notes:
- Prefer **URL-template search** (`/search?q=$INPUT`) over interacting with a search box.
- If the site is API-driven and the API is discoverable, record the API endpoints and required headers.

### Step 1.2 – Copilot classification

Copilot returns strict JSON (no prose):

```json
{
  "list_type": "movies",
  "confidence": 0.0,
  "rationale": "...",
  "suggested_recipe_shortcut": "example_movies"
}
```

Allowed `list_type` values are the existing folders at repo root (e.g. `albums`, `anime`, `artists`, `beers`, `boardgames`, `books`, `food`, `generic`, `manga`, `movies`, `podcasts`, `recipes`, `restaurants`, `software`, `songs`, `tv_shows`, `videogames`, `wines`).

### Step 1.3 – Path + filename decision

- `domain` = normalized hostname (lowercase, drop leading `www.`). Example: `www.theverge.com` → `theverge` (or `theverge.com` → `theverge`).
- Recipe path: `<list_type>/<domain>.json`.
- Test path: `<list_type>/<domain>.autorecipe.test.js`.

The script must refuse to overwrite existing files unless `--force` is passed.

---

## Phase 2: Autocomplete recipe generation (search)

### Step 2.1 – Decide the autocomplete contract

Minimum contract for any `autocomplete_steps`:
- Must produce **at least one** result entry.
- Must produce `TITLEn` and `URLn` for each entry.
- `SUBTITLEn` and `COVERn` are optional but strongly preferred when available.

### Step 2.2 – Choose a stable test query + expected target

Copilot proposes strict JSON:

```json
{
  "query": "Matrix",
  "expected": {
    "title": "The Matrix",
    "subtitle": "1999",
    "url_regex": "^https://www\\.themoviedb\\.org/movie/"
  }
}
```

The orchestrator can also *discover* a stable item by:
1) running a first draft autocomplete, then
2) picking the top result’s `URL1` and using its `TITLE1/SUBTITLE1` as the expected target.

### Step 2.3 – Author `autocomplete_steps`

Input to Copilot:
- evidence packet
- chosen query + expected target
- constraints: prefer stable locators, loops, URL-absolute normalization

Copilot returns strict JSON:

```json
{
  "autocomplete_steps": [ /* RecipeKit steps */ ],
  "assumptions": ["..."],
  "known_fragility": ["..."],
  "extra_probes_needed": ["..."]
}
```

### Step 2.4 – Write a complete recipe skeleton

The script composes (and validates) the full recipe JSON with:
- `recipe_shortcut`
- `list_type`
- `engine_version` (use `Engine/package.json` version)
- `title`, `description`
- `urls` (include hostname + `www.` variant or wildcard)
- `headers` (at minimum set `Accept-Language` + `User-Agent` consistent with other recipes)
- `autocomplete_steps` populated
- `url_steps` left empty or `null` for now

### Step 2.5 – Smoke-run the engine for autocomplete

Run:

bun Engine/engine.js --recipe <list_type>/<domain>.json --type autocomplete --input "<query>" --debug

Judge rules:
- output JSON parses
- `results` is a non-empty array
- at least one entry has a non-empty `TITLE` and `URL`
- optionally: one entry matches `expected.title` (and `expected.subtitle` if provided)

### Step 2.6 – Generate the bun test (autocomplete)

Write `<list_type>/<domain>.autorecipe.test.js` containing an `--type autocomplete` test that:
- runs engine with the chosen query
- uses `findEntry()` with expected title (and subtitle when present)
- asserts `URL` is present and matches `expected.url_regex` (or at least contains the hostname)

If the site is inherently unstable, tests should assert *structure* over exact values and use regexes.

### Step 2.7 – Repair loop (autocomplete)

Loop until green (or stop conditions):
1) capture failure (engine exception, empty results, selector misses)
2) probe again with agent-browser (only the minimal page needed)
3) send: failing output + evidence deltas + current recipe to Copilot “fixer”
4) apply patch (prefer surgical edits)
5) rerun: `bun test <list_type>/<domain>.autorecipe.test.js`

---

## Phase 3: URL/detail recipe generation (hydrate)

### Step 3.1 – Pick a stable detail URL

Use:
- the chosen expected autocomplete entry’s URL, or
- a known canonical URL discovered during probing.

### Step 3.2 – Probe the detail page

Evidence packet additions (detail):
- canonical URL
- JSON-LD blobs (or at least their `@type` and key fields)
- candidate selectors for: title, subtitle/year, author, cover, description, rating

### Step 3.3 – Decide required output fields (by list_type)

Use the existing repo test expectations as the default contract. Example baseline:
- `generic`: `TITLE`, `DESCRIPTION`, `FAVICON`, `COVER`
- `recipes`: `TITLE`, `COVER`, `INGREDIENTS`, `DESCRIPTION`, `STEPS`, `COOKING_TIME`, `DINERS`
- media-like types (`movies`, `tv_shows`, `anime`, `manga`, `videogames`): `TITLE`, `DATE`, `DESCRIPTION`, `RATING`, `AUTHOR`, `COVER` (+ type-specific fields like `DURATION`, `EPISODES`, `VOLUMES`)

### Step 3.4 – Author `url_steps`

Copilot returns strict JSON:

```json
{
  "url_steps": [ /* RecipeKit steps */ ],
  "outputs": [
    {"name": "TITLE", "type": "string"},
    {"name": "COVER", "type": "string"}
  ]
}
```

Hard rule: any field we want surfaced by the engine must be stored with `output.show: true` in the step that produces it.

### Step 3.5 – Smoke-run the engine for url

Run:

bun Engine/engine.js --recipe <list_type>/<domain>.json --type url --input "<detail_url>" --debug

Judge rules:
- output JSON parses
- `results` is a non-empty object
- required fields are present and non-empty (use regex checks for URLs/images)

### Step 3.6 – Generate the bun test (url)

In `<list_type>/<domain>.autorecipe.test.js`, add an `--type url` test asserting the required fields for that `list_type`.

### Step 3.7 – Repair loop (url)

Same loop as autocomplete, but include:
- the detail URL
- failed assertions
- current `url_steps`
- updated evidence packet

---

## Phase 4: Stop conditions

Success:
- `bun test <list_type>/<domain>.autorecipe.test.js` passes

Failure (hard stop):
- max iterations reached
- bot wall / CAPTCHA / login required
- site blocks headless browsing consistently
- evidence conflicts (e.g., multiple incompatible layouts)

On failure, output a final JSON report with:
- reason category
- last known failing command + locator
- evidence packet
- suggested next manual action

---

## Appendix

### agent-browser commands (conceptual)
- open
- snapshot --json
- click
- fill / type
- wait
- get text/html/attr/url/title

### Copilot SDK APIs (high-level)
- CopilotClient.start / stop
- createSession
- session.send
- session.on
- session.destroy

### RecipeKit engine flags
- --recipe
- --type autocomplete | url
- --input
- --debug
